---
id: testing-overview
title: Testing
author: Vojtech Novak
authorURL: 'https://twitter.com/vonovak'
description: このガイドではReact Native開発者に良いテストの書き方やどのようなテストを取り入れるべきかという、キーコンセプトを紹介します。
---

コードが大きくなるにつれて、予期しない小さなエラーやエッジケースが大きなエラーに繋がることがあります。バグは悪いユーザーエクスペリエンスとなり、究極的にはビジネス機会の損失になり得ます。脆弱なプログラミングを防ぐ方法の 1 つはリリースをする前にコードのテストを行うことです。

このガイドでは、静的分析から End-to-End テストに至るまで、アプリケーションが予期した動作をすることを自動で確認する方法を紹介します。

<img src="/docs/assets/diagram_testing.svg" alt="コードの修正、テスト、合格あるいは失敗といったサイクルでテストは行われます。" />

## なぜテストが必要か

私たちは人間で人間は過ちをするものです。テストは、ミスを明らかにしコードが正しく動作をしていることを確認するのに役立つため重要です。おそらく更に重要な事に、新機能を追加しても既存のコードをリファクタリングしても、あるいはプロジェクトの重大な依存関係の更新をしてもテストは将来もコードが動作し続ける事を保証してくれます。

テストにはあなたが思っている以上に価値があるでしょう。コード中のバグを直す最もよい方法の 1 つは、そのバグによって失敗しているテストを書くことです。その後、バグを直してテストを再度実行した時にテストがパスするということは、バグが直り二度とコードベースに持ち込まれない事を意味します。

テストは新しくチームに入った人へドキュメントを提供する事にもなります。実際のコードを見た事がない人でもテストを読む事によって既存のコードがどのように動くか理解しやすくなります。

最後になりますが大事なことに、テストが自動化されるにつれて手動で<abbr title="Quality Assurance">QA</abbr>テストをすることにかかる時間が少なくなり、貴重な時間を開放できます。

## 静的解析

コード品質改善の最初の一歩として、静的解析ツールを使いましょう。静的解析はコードを書くとコードを全く動かすことなくエラーを調べてくれます。

- **Linters** コードを解析すると使われていないコードを見つけたり、スペースの代わりに tab を使っている(設定次第ではその逆もあります)といった、スタイルガイドが禁止している書き方を見つけることができます。
- **Type checking** 　number 型が渡されることを期待している counting 関数に対して string が渡されるのを防ぐといったように、関数に渡しているデータ構造が関数によってあらかじめ設計されているものと一致している事を保証します。

React Native はすぐに使える設定済みの二種類のツールがあります。: [ESLint](https://eslint.org/) `lint`のためのツールです。[Flow](https://flow.org/en/docs/) または、 [TypeScript](typescript)(JavaScript にトランスパイル可能な型付き言語)、`Type checking`のためのツールです。

## テスタブルなコードを書く

テストを始めるにあたって、まず最初に必要なことはテストのしやすいコードを書くことです。航空機を作るプロセスを考えてみてください。 - いかなるモデルの機体でも、複雑なシステムが相互に全て正しく動いているかを確認するために飛ばしますが、それ以前に個々のパーツではテストが行われ安全であり正しく機能している事が保証されます。例えば翼は著しく重い負荷によって曲がるかをテストし、エンジンのパーツは耐久性をテストし、フロントガラスはバードインパクトをシミュレートしたテストがされます。

ソフトウェアも似ています。全体のプログラムをたくさんの行からなる巨大な 1 つのファイルとして書く代わりに、全体をテストするよりもより徹底してテストを行える小さなモジュールとしてコードを書きます。このようにして、テストをしやすいコードを書くということは、簡潔かつもジューラーなコードを書くこととなります。

アプリケーションをよりテストしやすくするには、React のコンポーネントのビューをロジックとステートに切り離すことから始めましょう。 (Redux, MobX その他どのようなソリューションを用いるとしてもです。) このようにして、React コンポーネントに依存してはいけないビジネスロジックのテストと、主にアプリケーションの UI をレンダリングすることが責務となるコンポーネントの独立性を保つことができます。

理論的には、全てのロジックとデータの取得をコンポーネントから移動させることができるはずです。こうすれば、コンポーネントはレンダリングに注力できます。ステートは完全にコンポーネントから独立するでしょう。アプリケーションのロジックはコンポーネントが一切存在しなくても動くはずです。

> 他の学習資料でテスタブルなコードについてのトピックをより深く調べてみることをお勧めします。

## テストを書く

テスタブルなコードを書いた次に、実際にいくつかテストを書いてみましょう。 React Native の初期状態のテンプレートは[Jest](https://jestjs.io)テストフレームワークを搭載しています。これにはこの環境に適したプリセットが含まれているので、config やモックを調整ぜずに生産的なテストを行うことができます[more on mocks](#moching)。Jest を使用してこのガイドで取り上げられている全てのタイプのテストを行うことができます。

> テスト駆動開発をするなら、テストを最初に書きましょう！そうすれば、テスタビリティがコードに与えられます。

### テストを構成する

あなたのテストは短く理想的には 1 つのことをテストするべきです。Jest で書かれたテストを例にとって始めましょう。

```js
it('given a date in the past, colorForDueDate() returns red', () => {
  expect(colorForDueDate('2000-10-20')).toBe('red');
});
```

このテストは[`it`](https://jestjs.io/docs/en/api#testname-fn-timeout)関数に渡す文字列で表現されます。これが何をテストするものなのか明確になるように気をつけて記述をしてください。以下のことを網羅することにベストを尽くしましょう。

1. **Given** - いくつかの前提となる条件
2. **When** - テスト対象の関数によって実行されるいくつかの挙動
3. **Then** - 予期される結果

これらはまた AAA(Arrange, Act, Assert)としても知られています。

Jest はテストを構成するのを助ける [`describe`](https://jestjs.io/docs/en/api#describename-fn) 関数を提供します。1 つの機能性に属する全てのテストをグループにまとめるのに `describe` を使用してください。describe 関数は必要であればネストして構いません。その他の関数でよく使われるものには[`beforeEach`](https://jestjs.io/docs/en/api#beforeeachfn-timeout) や [`beforeAll`](https://jestjs.io/docs/en/api#beforeallfn-timeout) があり、テストしたいオブジェクトの設定をするために使えます。詳細は[Jest api reference](https://jestjs.io/docs/en/api)を読んでください。

もしテストが多くのステップ、多くの結果をテストする時に、もっと小さくそれらを分けたくなるでしょう。そのようであれば、あなたのテストケースは他の機能から完全に独立することを保証してください。テストスイートの中のそれぞれのテストは他のテストケースが走り始めなくても、単体で実行できるようにしなければなりません。逆の見方をすると、全てのテストを一度に行う場合は、最初のテストが次のテストの結果に影響を与えてはいけません。

最後に、開発者として私たちはちゃんとコードが動いてクラッシュしないことを好みます。テストでは、よく反対のことが起きます。テストが失敗することを _良いこと_ だと捉えましょう。テストが失敗する時、多くの場合何かが間違っていることを意味します。それはユーザーに影響を与える前に問題を直す機会を与えてくれているのです。

## 単体テスト

単体テストは分離された関数やクラスのようにコードの最も小さな単位をカバーします。

テストされたオブジェクトが何かに依存する時、詳細は次のパラグラフで説明しますが、よくそれらをモックにする必要がでてきます。

単体テストの良い点は早く書けて早く実行できることです。ゆえに、作業の最中でもすぐにテストが通るかどうかについて知ることができます。Jest は編集中のコードに連動して継続的にテストを走らせるオプションを持っています。: [Watch mode](https://jestjs.io/docs/en/cli#watch)

<img src="/docs/assets/p_tests-unit.svg" alt=" " />

### モッキング

ときどき、テストをするオブジェクトは外部のコードに依存を持っていて、あなたはそれらをモックにしたいと考えるでしょう。モッキングはコードの外部への依存部分を任意の実装で置き換えることです。

> 一般的にテストにはモックを使うよりも実際のオブジェクトが使われることがことが好ましいですが、それが不可能なことがあります。例えば、あなたの JS のユニットテストが Java や Objective-C で書かれているネイティブモジュールに依存している場合など。

天気の情報を提供している外部のサービスやその他の依存コードを使って現在の街の天気を表示するアプリケーションを書くことを想像してみましょう。もしサービスが雨だと教えてくれるとき、雨雲の画像を表示したいとします。あなたは次のような理由でテストの中でそれらのサービスを呼び出したくないはずです。

- テストが遅くなり不安定になりえるから(ネットワークリクエストに巻き込まれて)
- サービスがテストのたびに違うデータを返してくる可能性がある
- サードパーティのサービスに繋がらない時でもテストを動かす必要があるから

それゆえに、サービスのモック実装することによって、何千にもおよぶ行のコードとインターネットに接続された温度系を効果的に置き換えることができます。

> Jest は[モックに関するサポート](https://jestjs.io/docs/en/mock-functions#mocking-modules)をあらゆる実装の関数レベルからモジュールレベルまで実現しています。

## 統合テスト

大きなソフトウェアシステムを書く時、個々のプログラムが相互にやりとりする必要があります。単体テストではあるプログラムが他のプログラムに依存していても、その依存をモックしてフェイクに置き換えることがありました。

統合テストでは、実際の個々のユニットを組み合わせて(実際のアプリケーションと同じように)それらが期待通りに協調して動くことを保証するためのテストをまとめて行います。だからと言って、モッキングが必要でなくなるわけではありません。まだモック(例えば、天気情報の通信のモック)を必要とするかもしれませんが、単体テストの時より必要とする機会はずっと少ないでしょう。

> 統合テストに関する用語の意味は必ずしも一貫性があるものではないことに注意してください。また、単体テストと統合テストの境界はいつでも明確とは限りません。このガイドでは、テストが以下のような時に統合テストに分類することとします。

> - 先に述べたようにアプリケーションにおける複数のモジュールが結合している時
> - 外部のシステムを使っている時
> - (天気サービスの API のような)他のアプリケーションをネットワークから呼び出している時
> - ファイルやデータベースの<abbr title="Input/Output">I/O</abbr>を行う時

<img src="/docs/assets/p_tests-integration.svg" alt=" " />

## コンポーネントテスト

React コンポーネントは描画に関する責務があり、ユーザーは描画されたものを直接触ります。例えあなたのビジネスロジックのテストカバレッジが高く正しいとしても、コンポーネントのテストなしではユーザーに壊れた UI を提供してしまう可能性があります。コンポーネントテストは単体テストあるいは統合テストに分類されることがありますが、React Native においては重要な部分なので、それらとは分けて見ていきましょう。

React コンポーネントをテストするというのも、2 つのことをテストしたいからです。

- インタラクション: ユーザーの操作に対しコンポーネントの正しい振る舞いを保証する(例: ボタンを押した時の挙動)
- レンダリング: React によってコンポーネントが結果を正しく表示していることを保証する(例: UI におけるボタンの見た目や位置)

例えば、ボタンが `onPress` リスナーを持っている時、コンポーネントによってボタンの見た目とボタンがタップされたときに正しく動くか、そのどちらもテストしたいとします。

これらのテストを助けるいくつかのライブラリがあります。

- React の[Test Renderer](https://reactjs.org/docs/test-renderer.html)、 React のコアと一緒に開発されていて、DOM やネイティブモバイル環境がなくても React のコンポーネントをピュアな JavaScript のオブジェクトに書き出せるレンダラーを提供します。
- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/)は React の `Test Renderer` にビルドされ、次のパラグラフで述べるような `fireEvent` や `query` API を追加します。

> コンポーネントテストは Node.js 環境での Javasdcript のみのテストです。それらは React Nativeのコンポーネントからブリッジされているいかなる iOS、Android、その他のプラットフォームのコードも _考慮しません_ 。このことは、それらが 100%の信頼を持ってユーザーに全てが動くことを保証するわけではないということです。もし、iOS や Android のコードにバグがあれば、それらは見つからないでしょう。

<img src="/docs/assets/p_tests-component.svg" alt=" " />

### ユーザーインタラクションのテスト

UI を描画する以外にも、コンポーネントは `TextInput` の `onChangeText` 、`Button`の `onPress` というようなイベントの操作をします。それらはイベントのコールバックやその他の関数を含むことがあります。
次の例を考えましょう。

```jsx
function GroceryShoppingList() {
  const [groceryItem, setGroceryItem] = useState('');
  const [items, setItems] = useState([]);

  const addNewItemToShoppingList = useCallback(() => {
    setItems([groceryItem, ...items]);
    setGroceryItem('');
  }, [groceryItem, items]);

  return (
    <>
      <TextInput
        value={groceryItem}
        placeholder="Enter grocery item"
        onChangeText={(text) => setGroceryItem(text)}
      />
      <Button
        title="Add the item to list"
        onPress={addNewItemToShoppingList}
      />
      {items.map((item) => (
        <Text key={item}>{item}</Text>
      ))}
    </>
  );
}
```

ユーザーインタラクションをテストするとき、ユーザーの視点から『ページに何があるのか、操作によって何が起きるか』をテストしてください。

経験則としてユーザーが、見ることができるもの、聞くことができるものを使う事が好ましいです。

- 描画された文字や[accessibility helpers](https://reactnative.dev/docs/accessibility#accessibility-properties)を使用してアサーションを作成する

逆に避けるべき事は以下の通りです。

- コンポーネントの props や state のアサーションを作成をすること
- testID のクエリ

テストを通すことは出来るとしても props やステートの実装の細かい部分をテストすることは避けてください。それらはリファクタリング(例えば、あなたが、それらのいくつかをリネームしたい時やクラスコンポーネントを hooks で書き直したい時)によって壊れやすくなりコンポーネントをユーザーがどう操作出来るかについて使う事には向いていません。

> React のクラスコンポーネントでは、特に内部のステートや props、イベントハンドラのような実装の細かい部分をテストしてしまうことがあります。実装の細かい部分をテストするのは避け、コンポーネントの内部に依存する事を _難しくする_ Hooks を用いた関数コンポーネントを用いるのが好ましいです。

[React Native Testing Library](https://callstack.github.io/react-native-testing-library/)のようなコンポーネントテストライブラリでは、提供されている API を注意深く選ぶことによりユーザー重視のテストが書きやすくなります。次の例では、`fireEvent`のメソッドである `changeText` と `press` を使いユーザーの操作をシミュレートし、`getAllByText`を用いて描画されたもの中からマッチする `Text` ノードを探索しています。

```jsx
test('given empty GroceryShoppingList, user can add an item to it', () => {
  const { getByPlaceholder, getByText, getAllByText } = render(
    <GroceryShoppingList />
  );

  fireEvent.changeText(
    getByPlaceholder('Enter grocery item'),
    'banana'
  );
  fireEvent.press(getByText('Add the item to list'));

  const bananaElements = getAllByText('banana');
  expect(bananaElements).toHaveLength(1); // 'banana' がリスト上に存在すること
});
```

この例では、関数を呼び出した時にどのようにステートが変化するかというロジックに関してテストをしているわけではありません。ユーザーが `TextInput` のテキストを変更して `Button` が押された時に起こる事についてテストしているのです。

### 描画結果のテスト

[Snapshot testing](https://jestjs.io/docs/en/snapshot-testing)は、Jest を使うことで可能になる高度なテストです。とても強力かつ低レベルなツールであり、使用する際には必要以上の注意をすることを勧めます。

コンポーネントのスナップショットは Jest に組み込まれているカスタムされた React のシリアライザによって作られる JSX のような文字列です。このシリアライザは Jest に React のコンポーネントツリーを人間が読めるような文字列に変換させます。言い換えるとコンポーネントのスナップショットはテスト中に _生成された_ 結果を描画したコンポーネントをテキストで表したものです。それは以下のような見た目になっています。

```jsx
<Text
  style={
    Object {
      "fontSize": 20,
      "textAlign": "center",
    }
  }>
  Welcome to React Native!
</Text>
```

スナップショットのテストを用いるとき、典型的には最初にコンポーネントを実装して、その後にスナップショットテストを実行しますスナップショットテストはレポジトリやファイルに参照用としてスナップショットを作成し保存します。 **そのファイルをコミットし、コードレビューの合間にチェックします**。コンポーネントの描画結果に関する変更はスナップショットを変化させるので、テストは失敗します。そうした時、あなたはテストをパスさせるために保存されている参照用のスナップショットを修正する必要があります。それらの変更をもう一度コミットし、レビューする必要があります。

スナップショットにはいくつか弱点があります。

- デベロッパーやレビュアーにとって、意図された変更によるものなのか、バグによるものなのかを区別するのが難しいのです。特に、大きなスナップショットはすぐに理解が難しくなり、それらを導入する価値が低くなります。
- スナップショットが作られた時に、出力結果が実際には間違っているケースでも正しいものと同様に扱われてしまいます。
- スナップショットが失敗した時に、その変更が意図通りのものなのかを適切に検証をせずに Jest の `--updateSnapshot` オプションを利用して更新したい誘惑に駆られます。開発者として確固たる自制心が必要です。

スナップショットそれ自体はロジックが正しいかを保証しません。それらはただ単に、予期しないような変更が発生することへの予防に役に立ち、テスト中の React ツリーのコンポーネントが期待通りに props(styles などの props)を受け取っているかをチェックするためのものです。

わたしたちは、小さなスナップショットだけを用いる事を推奨します。(詳しくは[`no-large-snapshots` rule](https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md)) もし 2 つの React のコンポーネントのステート間の _変更_ をテストしたいなら、[`snapshot-diff`](https://github.com/jest-community/snapshot-diff)を使ってください。疑わしい時は、疑わしい時は、前のパラグラフで述べたような明白な結果を期待する検証をすることが望ましいです。

<img src="/docs/assets/p_tests-snapshot.svg" alt=" " />

## End-to-End テスト

End-to-End テスト(E2E テスト)はユーザー視点でデバイス上(あるいはシミュレータやエミュレータ)で期待通りにアプリケーションが動いているか検証します。

これはアプリケーションがリリース設定でビルドされたものに対してテストを実行することによって実現します。E2E テストでは、もはや React コンポーネント、React Native の API、Redux の store やビジネスロジックについては考えません。それらは E2E テストの目的ではなく、 E2E のテストの間アクセスすらできません。

その代わり、E2E テストライブラリはアプリケーション上の画面の中から要素を探しだし操作することを可能にします。例えば、 *実際に*　現実の世界のユーザーと同等の手段でボタンをタップしたり、テキストを `TextInputs` に挿入できます。それからアプリケーションのスクリーンのなかに特定の要素が存在するか、見えているか、どんなテキストを含むかなどを検証できます。

E2E テストはアプリケーションが部分的に動く事について最も高い信頼を与えてくれます。以下のようなトレードオフはあります。

- 他のテスト手段に比べて記述に多くの時間がかかります。
- 実行が比較的遅いです。
- 結果が"フランキー"(まばら)になる傾向があります("フランキー"テストとはコードが同一でもランダムにパスしたり失敗したりするテストのことです)

E2E テストはアプリケーションにとって生命線となる機能で使ってください。: 認証のフロー、重要な機能、決済、などです。アプリケーションの死活にかかわらない機能はより速い JS のテストを使いましょう。テストを増やすに連れて信頼性は増しますが、メンテナンスやテストの実行により多くの時間をかけることにもなります。トレードオフを考えながらあなたにとって何がベストであるかを決めてください。

E2E テストに利用できるツールは複数あります。: React Native Community においては、React Native 用に調整されているので[Detox](https://github.com/wix/detox/)が人気のフレームワークです。その他にも iOS や Android アプリケーションにおいて人気のあるライブラリとして[Appium](http://appium.io/)があります。

<img src="/docs/assets/p_tests-e2e.svg" alt=" " />

## サマリー

私たちはこのガイドを読んで何かを学び楽しんでくれたことを願います。アプリケーションをテストできるたくさん方法があります。何を最初に使えばいいか決めるのは難しいこともあります。しかしながら、ひとたび React Native アプリケーションにテストが加わると、その全てが意味をなすようになると私たちは信じています。何を待つことがあるでしょうか？今すぐテストカバレッジを上げていきましょう。

### Links

- [React testing overview](https://reactjs.org/docs/testing.html)
- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/)
- [Jest docs](https://jestjs.io/docs/en/tutorial-react-native)
- [Detox](https://github.com/wix/detox/)
- [Appium](http://appium.io/)

---

_このガイドの原文は全て[Vojtech Novak](https://twitter.com/vonovak)によって書かれ寄稿されました。_
