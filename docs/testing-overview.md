---
id: testing-overview
title: Testing
author: Vojtech Novak
authorURL: 'https://twitter.com/vonovak'
description: このガイドではReact Native開発者に良いテストの書き方やどのようなテストを取り入れるべきかという、テストのキーコンセプト概念を紹介します。
---

コードが大きくなるにつれて、予期しない小さなエラーやエッジケースが大きなエラーに繋がることがあります。バグは悪いユーザーエクスペリエンスとなり、究極的にはビジネス機会の損失になり得ます。脆弱なプログラミングを防ぐ方法の 1 つはリリースをする前にコードのテストを行うことです。

このガイドでは、静的分析から End-to-End テストに至るまで、アプリケーションが予期した動作をすることを自動で確認する方法を紹介します。

<img src="/docs/assets/diagram_testing.svg" alt="コードの修正、テスト、合格あるいは失敗といったサイクルでテストは行われます。" />

## なぜテストが必要か

私たちは人間で人間は過ちをするものです。テストは、ミスを明らかにしコードが正しく動作をしていることを確認するのに役立つため重要です。おそらく更に重要な事に、新機能を追加しても既存のコードをリファクタリングしても、あるいはプロジェクトの重大な依存関係の更新をしてもテストは将来もコードが動作し続ける事を保証してくれます。

テストにはあなたが思っている以上に価値があるでしょう。コード中のバグを直す最もよい方法の 1 つは、そのバグによって失敗しているテストを書くことです。その後、バグを直してテストを再度実行した時にテストがパスするということは、バグが直り二度とコードベースに持ち込まれない事を意味します。

テストは新しくチームに入った人へドキュメントを提供する事にもなります。実際のコードを見た事がない人でもテストを読む事によって既存のコードがどのように動くか理解しやすくなります。

最後になりますが大事なことに、テストが自動化されるにつれて手動で<abbr title="Quality Assurance">QA</abbr>テストをする時間が少なくなり、貴重な時間を開放できます。

## 静的解析

コード品質改善の最初の一歩として、静的解析ツールを使いましょう。静的解析はコードを書くとコードを全く動かすことなくエラーを調べてくれます。


- **Linters** コードを解析すると使われていないコードを見つけたり、スペースの代わりに tab を使っている(設定次第ではその逆もあります)といった、スタイルガイドが禁止している書き方を見つけることができます。
- **Type checking** は、number 型が渡されることを期待している counting 関数に対して string が渡されるのを防ぐといったように、関数に渡しているデータ構造が関数によってあらかじめ設計されているものと一致している事を保証します。

React Native はすぐに使える設定済みの二種類のツールがあります。: [ESLint](https://eslint.org/) `lint`のためのツールです。[Flow](https://flow.org/en/docs/) または、 [TypeScript](typescript)(JavaScript にトランスパイル可能な型付き言語)、`Type checking`のためのツールです。

## テストのしやすいコードを書くこと

テストを始めるにあたって、まず最初に必要なことはテストのしやすいコードを書くことです。航空機を作るプロセスを考えてみてください。 - いかなるモデルの機体でも、複雑なシステムが相互に全て正しく動いているかを確認するために飛ばしますが、それ以前に個々のパーツではテストが行われ安全であり正しく機能している事が保証されます。例えば翼は著しく重い負荷によって曲がるかをテストし、エンジンのパーツは耐久性をテストし、フロントガラスはバードインパクトをシミュレートしたテストがされます。

ソフトウェアも似ています。全体のプログラムをたくさんの行のコードを巨大な 1 つのファイルへ書く代わりに、組み立てられたコード全体をテストする事よりも徹底的にテストが可能な小さな複数のモジュールとしてコードを書きます。この意味で、テストのしやすいコードは簡潔かつモジュラーに組み合わされています。

アプリケーションをよりテストしやすくするには、React のコンポーネントのビューをロジックとステートに切り離すことから始めましょう。 (Redux, MobX その他どのようなソリューションを用いるとしてもです。) このようにして、ビジネスロジックに関するテストを主にアプリケーションの UI 描画が責務となる React コンポーネントから独立に保つことができます。

理論的には、全てのロジックとデータの取得をコンポーネントから移動させることができるはずです。こうすれば、コンポーネントは単独でレンダリングに注力されます。ステートは全体的にコンポーネントから独立するでしょう。アプリケーションのロジックはコンポーネントが一切存在しなくても動くはずです。

> 他の学習資料についてもテスタブルなコードについての話題をより深く調べてみることもお勧めします。

## テストを書く

テストを描きやすいコードを書いた次に、実際にいくつかテストを書いてみましょう。 React Native の初期状態のテンプレートは[Jest](https://jestjs.io)テストフレームワークを搭載しています。テンプレートは、モックや設定をひねらなくてもストレートな道筋であなたを生産的にするように、事前に環境が仕立てられたプリセットを含んでいます-[モックをより詳しく](#mocking)。このガイド上のあらゆる種類の機能テストは Jest を使います。

> テスト駆動開発をするなら、テストを最初に書きます。そうすれば、テスタビリティがコードに与えられます。

## テストを構成する

あなたのテストは短く理想的には 1 つのことをテストするべきです。Jest で書かれたテストを例にとって始めましょう。

```js
it('given a date in the past, colorForDueDate() returns red', () => {
  expect(colorForDueDate('2000-10-20')).toBe('red');
});
```

このテストは[`it`](https://jestjs.io/docs/en/api#testname-fn-timeout)関数に渡す文字列で表現されます。これが何をテストするものなのか明確になるように気をつけて記述をしてください。以下のことを網羅することにベストを尽くしましょう。

1. **Given** - いくつかの前提となる条件
2. **When** - テスト対象の関数によって実行されるいくつかの挙動
3. **Then** - 予期される結果

これらはまた AAA(Arrange, Act, Assert)としても知られています。

Jest はテストを構成するのを助ける [`describe`](https://jestjs.io/docs/en/api#describename-fn) 関数を提供します。1 つの機能性に属する全てのテストをグループにまとめるのに `describe` を使用してください。describe 関数は必要であればネストして構いません。その他の関数でよく使われるものには[`beforeEach`](https://jestjs.io/docs/en/api#beforeeachfn-timeout) や [`beforeAll`](https://jestjs.io/docs/en/api#beforeallfn-timeout) があり、あなたがテストしたいオブジェクトの設定をするために使えます。より詳しくは[Jest api reference](https://jestjs.io/docs/en/api)を読んでください。

もしテストが多くのステップ、多くの結果をテストする時に、もっと小さくそれらを分けたくなるでしょう。そのようであれば、あなたのテストケースは他の機能から完全に独立することを保証してください。テストスイートの中のそれぞれのテストは他のテストケースが走り始めなくても、単体で実行できるようにしなければなりません。逆の見方をすると、全てのテストを一度に行う場合は、最初のテストが次のテストの結果に影響を与えてはいけません。

最後に、開発者として私たちはちゃんとコードが動いてクラッシュしないことを好みます。テストでは、よく反対のことが起きます。テストが失敗することを _良いこと_ だと捉えましょう。テストが失敗する時、多くの場合何かが間違っていることを意味します。それはユーザーに影響を与える前に問題を直す機会を与えてくれているのです。

## 単体テスト

単体テストは分離された関数やクラスのようにコードの最も小さな単位をカバーします。

テストされたオブジェクトが何かに依存する時、詳細は次のパラグラフで説明しますが、よくそれらをモックにする必要がでてきます。

単体テストの良い点は早く書けて早く実行できることです。ゆえに、作業の最中でもすぐにテストが通るかどうかについて知ることができます。Jest は編集中のコードに連動して継続的にテストを走らせるオプションを持っています。: [Watch mode](https://jestjs.io/docs/en/cli#watch)

<img src="/docs/assets/p_tests-unit.svg" alt=" " />

### モッキング

ときどき、テストをするオブジェクトは外部のコードに依存を持っていて、あなたはそれらをモックにしたいと考えるでしょう。モッキングはコードの外部への依存部分を任意の実装で置き換えることです。

> 一般的にテストにはモックを使うよりも実際のオブジェクトが使われることがことが好ましいですが、それが不可能なことがあります。例えば、あなたの JS のユニットテストが Java や Objective-C で書かれているネイティブモジュールに依存している場合など。

天気の情報を提供している外部のサービスやその他の依存コードを使って現在の街の天気を表示するアプリケーションを書くことを想像してみましょう。もしサービスが雨だと教えてくれるとき、雨雲の画像を表示したいとします。あなたは次のような理由でテストの中でそれらのサービスを呼び出したくないはずです。

- テストが遅くなり不安定になりえるから(ネットワークリクエストに巻き込まれて)
- サービスがテストのたびに違うデータを返してくる可能性がある
- サードパーティのサービスに繋がらない時でもテストを動かす必要があるから

それゆえに、あなたは何千行ものコードとインターネットに繋がれた温度計を効果的に置き換えるサービス実装のモックを必要とすることがあります。

> Jest は[モックに関するサポート](https://jestjs.io/docs/en/mock-functions#mocking-modules)をあらゆる実装の関数レベルからモジュールレベルまで実現しています。

## 統合テスト

大きなソフトウェアシステムを書く時、個々のプログラムが相互にやりとりする必要があります。単体テストではあるプログラムが他のプログラムに依存していても、たびたび、それらを最終的にフェイクに置き換えて依存をモックにします。

統合テストでは、実際の個々のユニットを組み合わせて(実際のアプリケーションと同じように)それらが期待通りに協調して動くことを保証するためのテストをまとめて行います。だからと言って、モッキングが必要でなくなるわけではありません。あなたはまだモック(例えば、天気情報の通信のモック)を必要とするかもしれませんが、単体テストの時より必要とする機会はずっと少ないでしょう。

> 統合テストに関する用語の意味は必ずしも一貫性があるものではないことに注意してください。また、単体テストと統合テストの境界はいつでも明確とは限りません。このガイドにとってあなたのテストが統合テストを意味する時はテストが以下のような時です。

> - 述べてきたようにアプリケーションが複数のモジュールの組み合わせになっている時
> - 外部のシステムを使っている時
> - (天気サービスの API のような)他のアプリケーションをネットワークから呼び出している時
> - ファイルやデータベースの<abbr title="Input/Output">I/O</abbr>を行う時

<img src="/docs/assets/p_tests-integration.svg" alt=" " />

## コンポーネントテスト

React コンポーネントは描画に関する責務があり、ユーザーは直接描画されたものに対して相互にやりとりするでしょう。例えあなたのビジネスロジックのテストカバレッジが高く正しいとしても、コンポーネントのテストなしではユーザーに壊れた UI を提供してしまう可能性があります。コンポーネントテストは単体テストあるいは統合テストに分類されることがありますが、React Native においては重要な部分なので、それらとは分けて見ていきましょう。

React コンポーネントをテストするというのも、2 つのことをテストしたいからです。

- インタラクション: ユーザーからの要求にコンポーネントの正しい振る舞いを保証する(例: ボタンを押した時の挙動)
- レンダリング: React によってコンポーネントが結果を正しく表示していることを保証する(例: UI におけるボタンの見た目や位置)

例えば、ボタンが `onPress` リスナーを持っている時、コンポーネントによってボタンの見た目とボタンがタップされたときに正しく動くか、そのどちらもテストしたいとします。

これらのテストを助けるいくつかのライブラリがあります。

- React の[Test Renderer](https://reactjs.org/docs/test-renderer.html)、 React のコアと一緒に開発されていて、DOM やネイティブモバイル環境がなくても React のコンポーネントをピュアな JavaScript のオブジェクトに書き出せるレンダラーを提供します。
- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/)は React の `Test Renderer` にビルドされ、次のパラグラフで述べるような `fireEvent` や `query` API を追加します。

> コンポーネントテストは Node.js 環境での Javasdcript のみのテストです。それらは React Native のコンポーネントから渡されるいかなる iOS、Android、その他のプラットフォームのコードも _考慮しません_ 。このことは、それらが 100%の信頼を持ってユーザーに全てが動くことを保証するわけではないということです。もし、iOS や Android のコードにバグがあれば、それらは見つからないでしょう。

<img src="/docs/assets/p_tests-component.svg" alt=" " />

### ユーザーインタラクションのテスト

UI を描画する以外にも、コンポーネントは `TextInput` の `onChangeText` 、`Button`の `onPress` というようなイベントの操作をします。それらはイベントのコールバックやその他の関数を含むことがあります。
次の例を考えましょう。

```jsx
function GroceryShoppingList() {
  const [groceryItem, setGroceryItem] = useState('');
  const [items, setItems] = useState([]);

  const addNewItemToShoppingList = useCallback(() => {
    setItems([groceryItem, ...items]);
    setGroceryItem('');
  }, [groceryItem, items]);

  return (
    <>
      <TextInput
        value={groceryItem}
        placeholder="Enter grocery item"
        onChangeText={(text) => setGroceryItem(text)}
      />
      <Button
        title="Add the item to list"
        onPress={addNewItemToShoppingList}
      />
      {items.map((item) => (
        <Text key={item}>{item}</Text>
      ))}
    </>
  );
}
```

ユーザーインタラクションをテストするとき、ユーザーの視点からページに何があるのか、操作によって何が起きるかをテストしてください。

経験則としてユーザーが、見ることができるもの、聞くことができるものを使う事が好ましいです。

- 書かれている文字や[accessibility helpers](https://reactnative.dev/docs/accessibility#accessibility-properties)にアサーションを行う

逆に避けるべき事は以下の通りです。

- コンポーネントの props やステートにアサーションを行う事
- testID のクエリ

テストを通すことは出来るとしても props やステートの実装の細かい部分をテストすることは避けてください。それらはリファクタリング(例えば、あなたが、それらのいくつかをリネームしたい時やクラスコンポーネントを hooks で書き直したい時)によって壊れがちになりコンポーネントをユーザーがどう操作出来るかについて使う事には向いていません。

> React のクラスコンポーネントは特にインターナルなステートや props、イベントハンドラのような実装の細かい部分をテストしがちです。実装の細かい部分をテストするのは避け、コンポーネントの内部に依存する事を _難しくする_ Hooks を用いた関数コンポーネントを用いるのが好ましいです。

[React Native Testing Library](https://callstack.github.io/react-native-testing-library/)のようなコンポーネントをテストするライブラリは、API の適切な選択によってユーザー視点でのテストが出来ます。次の例では、`changeText`と `press` メソッドを持ち、ユーザーのコンポーネントに対する操作をシミュレートする `fireEvent` と、レンダリングされた `Text` ノードからマッチするものを探す `getAllByText` クエリファンクションを用いています。

```jsx
test('given empty GroceryShoppingList, user can add an item to it', () => {
  const { getByPlaceholder, getByText, getAllByText } = render(
    <GroceryShoppingList />
  );

  fireEvent.changeText(
    getByPlaceholder('Enter grocery item'),
    'banana'
  );
  fireEvent.press(getByText('Add the item to list'));

  const bananaElements = getAllByText('banana');
  expect(bananaElements).toHaveLength(1); // 'banana' がリスト上に存在するはず
});
```

この例では、関数を呼び出した時にどのようにステートが変化するかというロジックに関してテストをしているわけではありません。ユーザーが `TextInput` のテキストを変更して `Button` が押された時に起こる事についてテストしているのです。

### 描画結果のテスト

[Snapshot testing](https://jestjs.io/docs/en/snapshot-testing)は、Jest による発展的なテストを可能にするものです。とても強力で低レベルなツールであり、使うと特別な注意を促してくれます。

コンポーネントのスナップショットは Jest に組み込まれているカスタムされた React のシリアライザによって作られる JSX のような文字列です。このシリアライザは Jest に React のコンポーネントツリーを人間が読めるような文字列に翻訳させます。言い換えるとコンポーネントのスナップショットはテストを走らせる間に _生成された_ 結果を描画したコンポーネントをテキストで再表現したものです。それは以下のような見た目になっています。

```jsx
<Text
  style={
    Object {
      "fontSize": 20,
      "textAlign": "center",
    }
  }>
  Welcome to React Native。
</Text>
```

スナップショットのテストを用いるとき、典型的には最初にコンポーネントを実装して、その後にスナップショットテストを実行します。スナップショットテストはあなたのレポジトリやファイルに参照用のスナップショットとしてスナップショットを作成し保存します。 **そのファイルはコミットし、コードレビューの合間にチェックします**。コンポーネントの描画の出力結果に関するいかなる変更もスナップショットを変化させ、テストを失敗させます。そうした時、あなたはテストをパスさせるために保存されている参照用のスナップショットを修正する必要があります。それらの変更をもう一度コミットし、レビューする必要があります。

スナップショットにはいくつか弱点があります。

- あなたのようなデベロッパーやレビュアーにとって、意図された変更なのか、はたまたバグの証拠なのかを区別するのが難しいのです。特に、大きなスナップショットはすぐに理解が難しくなり、それらを導入する価値が低くなります。
- スナップショットが作られた時点では、出力結果が実際には間違っているケースでも正しいものと同様に扱われてしまうこと。
- スナップショットが失敗した時に、その変更が意図通りのものなのかを適切に検証をせずに Jest の `--updateSnapshot` オプションを利用して更新したい誘惑に駆られます。ある程度開発者としての自制心が必要です。

スナップショットそれ自体はロジックが正しいかを保証しません。それらはただ単に、予期しないような変更が発生することへの予防に役に立ち、テスト中の React ツリーのコンポーネントが期待通りに props(styles などの props)を受け取っているかをチェックするためのものです。

わたしたちは、小さなスナップショットだけを用いる事を推奨します。(詳しくは[`no-large-snapshots` rule](https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md)) もし、あなたが 2 つの React のコンポーネントのステート間の _変更_ をテストしたいなら、[`snapshot-diff`](https://github.com/jest-community/snapshot-diff)を使ってください。疑わしい時は、前のパラグラフで述べたような明示的に期待する検証をすることが望ましいです。

<img src="/docs/assets/p_tests-snapshot.svg" alt=" " />

## End-to-End テスト

End-to-End テスト(E2E テスト)はユーザー視点でデバイス上(あるいはシミュレータやエミュレータ)で期待通りにアプリケーションが動いているか検証します。

これはアプリケーションがリリース設定でビルドされたものに対してテストを実行することによって実現します。E2E テストでは、もはや React コンポーネント、React Native の API、Redux の store やビジネスロジックについては考えません。ビジネスロジックについて考える事は E2E テストの目的ではなく、それらは E2E のテストの間アクセスすらできません。

その代わり、E2E テストライブラリはアプリケーション上の画面の中から要素を探しだし操作することを可能にします。例えば、 *実際に*　現実の世界のユーザーと同等の手段でボタンをタップしたり、テキストを `TextInputs` に挿入できます。それからアプリケーションのスクリーンのなかに特定の要素が存在するか、見えているか、どんなテキストを含むかなどを検証できます。

E2E テストはアプリケーションが部分的に動く事について最も高い信頼を与えてくれます。以下のようなトレードオフはあります。

- 他のテスト手段に比べて記述に多くの時間がかかります。
- 実行が比較的遅いです。
- 結果が"フランキー"(まばら)になる傾向があります("フランキー"テストとはコードが同一でもランダムにパスしたり失敗したりするテストのことです)

E2E テストはアプリケーションにとって生命線となる機能で使ってください。: 認証のフロー、重要な機能、決済、などです。アプリケーションの死活にかかわらない機能はより速い JS のテストを使いましょう。テストを増やすに連れて信頼性は増しますが、メンテナンスやテストの実行により多くの時間をかけることにもなります。トレードオフを考えながらあなたにとって何がベストであるかを決めてください。

E2E テストに利用できるツールは複数あります。: React Native Community においては、[Detox](https://github.com/wix/detox/)が人気のフレームワークで React Native のアプリケーションのために利用できます。その他にも iOS や Android アプリケーションにおいて人気のあるライブラリとして[Appium](http://appium.io/)があります。

<img src="/docs/assets/p_tests-e2e.svg" alt=" " />

## サマリー

私たちはあなたがこのガイドを読んで何かを学び楽しんでくれたことを願います。アプリケーションをテストできるたくさん方法があります。何を最初に使えばいいか決めるのは難しいこともあります。しかしながら、その全てがあなたの素晴らしい React Native のアプリケーションへ加わった途端に役に立つと信じています。何を待つことがあるでしょうか。今すぐカバレッジを上げましょう。

### Links

- [React testing overview](https://reactjs.org/docs/testing.html)
- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/)
- [Jest docs](https://jestjs.io/docs/en/tutorial-react-native)
- [Detox](https://github.com/wix/detox/)
- [Appium](http://appium.io/)

---

_このガイドの原文は全て[Vojtech Novak](https://twitter.com/vonovak)によって書かれ寄稿されました。_
